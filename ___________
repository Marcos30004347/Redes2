#include "tcp_server.h"

#include "signals.h"
#include "async.h"

#include <netinet/in.h> 
#include <sys/socket.h> 
#include <sys/types.h>

#include <stdlib.h>
#include <stdio.h> 
#include <string.h> 
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>

struct connection_node_t {
    int                             client;
    struct thread_t*                thread;
    
    struct connection_node_t*       next;
    struct connection_node_t*       prev;
};

struct connection_t {
    int                             client_fd;
    struct sockaddr_in              client_address;
};

struct thread_data {
    struct tcp_server_t*            server;
    int                             connfd;
};

struct tcp_connection_t {
    tcp_server_t*   server;
    int             client_fd;
};

struct tcp_server_t {
    int                             server_fd;
    struct sockaddr_storage         address;
    struct connection_node_t*       connections;
    tcp_server_t_handler            handler;
};



long receive_from_connection(tcp_connection_t* con, void* buffer, int len) 
{
    return read(con->client_fd, buffer, len);
}

long write_to_connection(tcp_connection_t* con, void* buffer, int len) 
{
    write(con->client_fd, buffer, len); 
}

void* tcp_server_t_client_handler(void* _data)
{
    struct thread_data* data = (struct thread_data*)(_data);
    tcp_connection_t connection;
    connection.client_fd    = data->connfd;
    connection.server       = data->server;

    data->server->handler(&connection, receive_from_connection, write_to_connection);

    free(data);

    return NULL;
}

void tcp_server_t_hold_connection(struct tcp_server_t* server, struct connection_t connection) {
    struct thread_t* thread = NULL;

    struct thread_data* data =(struct thread_data*) malloc(sizeof(struct thread_data));

    data->connfd = connection.client_fd;
    data->server = server;

    struct connection_node_t* conn = (struct connection_node_t*)malloc(sizeof(struct connection_node_t));

    if(!data->server->connections)
    {
        data->server->connections = conn;
    }
    else
    {
        data->server->connections->next = conn;
        conn->prev = data->server->connections;
        data->server->connections = conn;
    }

    thread_t_create(&thread, tcp_server_t_client_handler, data);

    conn->thread = thread;
    conn->client = connection.client_fd;
}
void reverse(char s[])
{
    int i, j;
    char c;

    for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}  
void itoa(int n, char s[])
{
    int i, sign;

    if ((sign = n) < 0)  /* record sign */
        n = -n;          /* make n positive */
    i = 0;
    do {       /* generate digits in reverse order */
        s[i++] = n % 10 + '0';   /* get next digit */
    } while ((n /= 10) > 0);     /* delete it */
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}  

void tcp_server_t_create(struct tcp_server_t** server,  tcp_server_t_handler handler, int port)
{
    int no = 0;
    int reuseaddr = 1;

    *server = (struct tcp_server_t*)malloc(sizeof(struct tcp_server_t));
    
    // struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&(*server)->address;
    
    
    struct addrinfo hints, *res;
    memset(&hints, 0, sizeof hints);

    hints.ai_family = AF_UNSPEC; // use IPv4 or IPv6, whichever
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;

    char snum[5];

    itoa(port, snum);
    printf("%s\n",snum);

    if (0 != getaddrinfo(NULL, snum, &hints, &res))
    {
        printf("asdasdasdasd\n");
        exit(-1);
    }

    (*server)->server_fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    setsockopt((*server)->server_fd, IPPROTO_IPV6, IPV6_V6ONLY, (void *)&no, sizeof(no)); 
    setsockopt((*server)->server_fd, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));
 
    (*server)->connections = NULL;
    (*server)->handler = handler;

    // addr6->sin6_family = AF_INET6;
    // addr6->sin6_port = htons(port);
    // addr6->sin6_addr = in6addr_any;

    if ((*server)->server_fd == -1) { 
        printf("[ERROR]: criacao do socket falhou!\n"); 
        exit(0); 
    }

    if ((bind((*server)->server_fd, res->ai_addr, res->ai_addrlen) != 0)) { 
        printf("socket bind failed...\n"); 
        exit(0); 
    } 
}

void tcp_server_t_destroy(struct tcp_server_t* server)
{
    struct connection_node_t * tmp;
    while (server->connections)
    {
        tmp = server->connections;

        server->connections = server->connections->prev;
        if(server->connections)
            server->connections->next = NULL;

        thread_t_destroy(tmp->thread);
        free(tmp);
    }

    free(server);
}

struct connection_t tcp_server_t_accept_connection(struct tcp_server_t* server)
{
    struct connection_t conn;
    socklen_t len = sizeof(conn.client_address); 
    conn.client_fd = accept(server->server_fd, (struct sockaddr*)&conn.client_address, &len); 
    return conn;
}

void tcp_server_t_start(struct tcp_server_t* server)
{
    if ((listen(server->server_fd, 5)) != 0) { 
        printf("[ERROR]: Nao foi possivel escutar\n"); 
        exit(0); 
    }

    printf("listening...\n");
    struct connection_t connection = tcp_server_t_accept_connection(server);

    while(connection.client_fd != -1)
    {
        tcp_server_t_hold_connection(server, connection);
        connection = tcp_server_t_accept_connection(server);
    }
}

void tcp_server_t_terminate(struct tcp_server_t* server)
{
    struct connection_node_t * tmp = server->connections;

    close(server->server_fd);
}

void tcp_server_t_disconnect_client(struct tcp_connection_t* conn)
{
    close(conn->client_fd);
}

int tcp_connection_t_get_id(struct tcp_connection_t* connection) {
    return connection->client_fd + 2020;
}